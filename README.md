# WMI-2 (Leak via Type Confusion) — KLEE Demo

Standalone repo to detect **WMI-2: information leak via type confusion** in the MetaLogin C codebase using KLEE symbolic execution and a STASE-style pipeline.

## What This Demo Does

- **Bug:** After `set_avatar` → `clear_avatar`, `g_session.current_avatar` is a stale pointer. A later `set_start_location()` allocates new objects; the allocator may reuse the freed avatar memory. Code that reads the "username" field from the stale pointer can then observe **heap pointer values** as if they were user data (information leak / type confusion).
- **Assertion:** The 8-byte value at `(current_avatar + offsetof(avatar, username))` must **not** be a valid heap address. If it is, we report a leak (KLEE assertion failure).

## Requirements

- **KLEE** (with LLVM/clang) — typically on Linux/Ubuntu.
- **clang** with `-emit-llvm`, **llvm-link**.

## Quick Start (on a machine with KLEE)

```bash
cd /path/to/wmi2_klee_demo
./stub_wmi2.sh
KLEE_INC=/path/to/klee/include ./build_wmi2.sh
./run_wmi2.sh
```

If `klee.h` is in a custom path, set `KLEE_INC`:

```bash
export KLEE_INC=$(klee-config --includedir)   # if klee-config exists
./build_wmi2.sh
./run_wmi2.sh
```

## Layout

| File | Role |
|------|------|
| `metalogin.c`, `metalogin.h`, `globals.c` | Target C codebase (MetaLogin). |
| `driver_wmi2_leak.c` | Symbolic driver: runs the WMI-2 path and asserts no heap pointer in the "username" field. |
| `stubs_wmi2.c` | Generated by `stub_wmi2.sh`: libc/I/O stubs; `fgets` returns `"127\n"` so `set_start_location` allocates. |
| `stub_wmi2.sh` | Writes `stubs_wmi2.c`. |
| `build_wmi2.sh` | Builds `wmi2_demo.bc` (driver + stubs + metalogin + globals). |
| `run_wmi2.sh` | Runs KLEE on `wmi2_demo.bc`. |

## Modeling Summary

1. **Path:** `init_system()` → `set_avatar()` → `clear_avatar()` → `set_start_location()` → read `current_avatar->username`.
2. **Symbolic inputs:** `username` and `access_code` (null-terminated, non-empty username).
3. **Stubs:** Same idea as WMI-1; for WMI-2, `fgets` must return data so `set_start_location` actually allocates (here: `"127\n"`).
4. **Assertion:** Value at the stale "username" field must not lie in KLEE’s heap range (`HEAP_START`–`HEAP_END` in the driver). Adjust these if your KLEE allocator uses different bounds.

## Expected Result

When the freed chunk is reused and the overwritten "username" slot contains a heap pointer, KLEE hits the assertion and reports an error (information leak). Check `klee-out-*/` for the failing test and messages.
